/// <reference types="node" />
/**
 * Copyright 2014 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { AuthenticationConfig } from '../types/common-types';
import { EventEmitter } from 'events';
import { Debuggee } from '../debuggee';
import { Breakpoint } from '../types/api-types';
import { DebugAgentConfig } from './config';
import { Debug } from '../debug';
export declare class Debuglet extends EventEmitter {
    private config_;
    private debug_;
    private v8debug_;
    private running_;
    private project_;
    private fetcherActive_;
    private logger_;
    private debugletApi_;
    private debuggee_;
    private activeBreakpointMap_;
    private completedBreakpointMap_;
    /**
     * @param {Debug} debug - A Debug instance.
     * @param {object=} config - The option parameters for the Debuglet.
     * @event 'started' once the startup tasks are completed. Only called once.
     * @event 'stopped' if the agent stops due to a fatal error after starting.
     * Only called once.
     * @event 'registered' once successfully registered to the debug api. May be
     *     emitted multiple times.
     * @event 'remotelyDisabled' if the debuggee is disabled by the server. May be
     *    called multiple times.
     * @constructor
     */
    constructor(debug: Debug, config: DebugAgentConfig);
    static normalizeConfig_(config: DebugAgentConfig): DebugAgentConfig;
    /**
     * Starts the Debuglet. It is important that this is as quick as possible
     * as it is on the critical path of application startup.
     * @private
     */
    start(): Promise<void>;
    /**
     * @private
     */
    static createDebuggee(projectId: string, uid: string, serviceContext: {
        service: string | null;
        version: string | null;
        minorVersion_: string | null;
    }, sourceContext: {
        [key: string]: string;
    }, description: string | null, errorMessage: string | null, onGCP: boolean): Debuggee;
    static getProjectId(options: AuthenticationConfig): Promise<string>;
    static runningOnGCP(): Promise<boolean>;
    static getProjectIdFromMetadata(): Promise<string>;
    static getClusterNameFromMetadata(): Promise<string>;
    getSourceContext_(callback: (err: Error | string, sourceContext: {
        [key: string]: string;
    }) => void): void;
    /**
     * @param {number} seconds
     * @private
     */
    scheduleRegistration_(seconds: number): void;
    /**
     * @param {number} seconds
     * @private
     */
    scheduleBreakpointFetch_(seconds: number): void;
    /**
     * Given a list of server breakpoints, update our internal list of breakpoints
     * @param {Array.<Breakpoint>} breakpoints
     * @private
     */
    updateActiveBreakpoints_(breakpoints: Breakpoint[]): void;
    /**
     * Array of breakpints get converted to Map of breakpoints, indexed by id
     * @param {Array.<Breakpoint>} breakpointList
     * @return {Object.<string, Breakpoint>} A map of breakpoint IDs to breakpoints.
     * @private
     */
    convertBreakpointListToMap_(breakpointList: Breakpoint[]): {
        [key: string]: Breakpoint;
    };
    /**
     * @param {Breakpoint} breakpoint
     * @private
     */
    removeBreakpoint_(breakpoint: Breakpoint): void;
    /**
     * @param {Breakpoint} breakpoint
     * @return {boolean} false on error
     * @private
     */
    addBreakpoint_(breakpoint: Breakpoint, cb: (ob: Error | string) => void): void;
    /**
     * Update the server that the breakpoint has been completed (captured, or
     * expired).
     * @param {Breakpoint} breakpoint
     * @private
     */
    completeBreakpoint_(breakpoint: Breakpoint): void;
    /**
     * Update the server that the breakpoint cannot be handled.
     * @param {Breakpoint} breakpoint
     * @private
     */
    rejectBreakpoint_(breakpoint: Breakpoint): void;
    /**
     * This schedules a delayed operation that will delete the breakpoint from the
     * server after the expiry period.
     * FIXME: we should cancel the timer when the breakpoint completes. Otherwise
     * we hold onto the closure memory until the breapointExpirateion timeout.
     * @param {Breakpoint} breakpoint Server breakpoint object
     * @private
     */
    scheduleBreakpointExpiry_(breakpoint: Breakpoint): void;
    /**
     * Stops the Debuglet. This is for testing purposes only. Stop should only be
     * called on a agent that has started (i.e. emitted the 'started' event).
     * Calling this while the agent is initializing may not necessarily stop all
     * pending operations.
     */
    stop(): void;
    /**
     * Performs a set subtract. Returns A - B given maps A, B.
     * @return {Array.<Breakpoint>} A array containing elements from A that are not
     *     in B.
     */
    static mapSubtract<T, U>(A: {
        [key: string]: T;
    }, B: {
        [key: string]: U;
    }): T[];
    /**
     * Formats the message base with placeholders `$0`, `$1`, etc
     * by substituting the provided expressions. If more expressions
     * are given than placeholders extra expressions are dropped.
     */
    static format(base: string, exprs: string[]): string;
    static _tokenize(base: string, exprLength: number): Array<{
        v: string;
    } | string>;
    static _delimit(source: string, delim: string): Array<{
        v: string;
    } | string>;
    static _createUniquifier(desc: string, version: string, uid: string, sourceContext: {
        [key: string]: any;
    }, labels: {
        [key: string]: string;
    }): string;
}
